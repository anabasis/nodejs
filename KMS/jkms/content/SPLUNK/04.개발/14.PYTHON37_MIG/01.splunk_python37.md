
# Python3 Migration

## Python 3 migration with the Splunk platform

>> Check this manual often for updated information about the Splunk platform Python 3 migration. The content is subject to change.
>> Splunk 플랫폼 Python 3 마이그레이션에 대한 업데이트 된 정보는이 매뉴얼을 자주 확인하십시오. 내용은 변경 될 수 있습니다.

On January 1, 2020, Python version 2.x will no longer be supported by the Python Software Foundation. Existing Python packages and tools will end support for Python 2, and new Python packages won't support Python 2. This will not impair Splunk's ability to provide support for Splunk Enterprise, including Python 2.7. However, to continue to leverage community support and maintain compatibility with the many third party projects that use Python, Splunk will migrate Splunk Enterprise, supported Premium Solutions, and supported Splunkbase apps and add-ons to Python 3.7 compatibility.

2020 년 1월 1일부터 Python Software Foundation 은 Python 버전 2.x를 더 이상 지원하지 않습니다 . 기존 Python 패키지 및 도구는 Python 2에 대한 지원을 종료하고 새로운 Python 패키지는 Python 2를 지원하지 않습니다. 이는 Python 2.7을 포함하여 Splunk Enterprise에 대한 지원을 제공하는 Splunk의 기능을 손상시키지 않습니다. 그러나 커뮤니티 지원을 계속 활용하고 Python을 사용하는 많은 타사 프로젝트와의 호환성을 유지하기 위해 Splunk는 Splunk Enterprise, 지원되는 프리미엄 솔루션 및 지원되는 Splunkbase 앱 및 추가 기능을 Python 3.7 호환성으로 마이그레이션합니다.

This manual helps identify prerequisites, required changes and steps for migrating impacted Splunk products and apps to Python 3. As Splunk makes new tools and advice available, this content will be updated. When this content is revised, changes updates will be tracked in Splunk Answers.

이 매뉴얼은 영향을 받는 Splunk 제품 및 앱을 Python 3으로 마이그레이션하기 위한 필수 구성 요소, 필수 변경 사항 및 단계를 식별하는 데 도움이됩니다. Splunk는 새로운 도구와 조언을 제공하므로이 내용이 업데이트됩니다. 이 컨텐츠가 개정되면 Splunk Answers 에서 변경 사항 업데이트가 추적됩니다 .

Splunk has released Splunk Enterprise version 8.0 to support the migration from Python 2 to Python 3. Splunk has migrated impacted features to Python 3.7, and Splunk Enterprise version 8.0 includes both the Python 2.7 and Python 3.7 runtimes, to help customers and developers transition Python in apps from Python 2 to Python 3. Splunk will remove the Python 2.7 runtime altogether in a future release.

Splunk는 Python 2에서 Python 3으로의 마이그레이션을 지원하기 위해 Splunk Enterprise 버전 8.0을 출시했습니다. Splunk는 영향을받은 기능을 Python 3.7로 마이그레이션했으며 Splunk Enterprise 버전 8.0에는 Python 2.7 및 Python 3.7 런타임이 모두 포함되어있어 고객과 개발자가 Python을 Splunk는 향후 릴리스에서 Python 2.7 런타임을 완전히 제거합니다.

### Splunk administrators

Splunk administrators might need to take steps to prepare for Python 3.7 in Splunk Enterprise version 8.0, as there are prerequisites to this upgrade. See details in Changes to Splunk Enterprise.

Splunk 관리자는 이 업그레이드의 전제 조건이 있으므로 Splunk Enterprise 버전 8.0에서 Python 3.7을 준비하기위한 단계를 수행해야 할 수도 있습니다. Splunk Enterprise 변경 사항을 참조하십시오

### Splunk developers

Splunk app and add-on developers must revise apps and add-ons that use Python scripts. Revised Splunkbase apps will need to be resubmitted after validation with Splunk Enterprise version 8.0. For details about specific script changes required to support Splunk Enterprise version 8.0, see Python Development in Splunk Enterprise.

Splunk 앱 및 애드온 개발자는 Python 스크립트를 사용하는 앱 및 애드온을 수정해야합니다. Splunk Enterprise 버전 8.0으로 유효성 검사 후 수정 된 Splunkbase 앱을 다시 제출해야합니다. Splunk Enterprise 버전 8.0을 지원하는 데 필요한 특정 스크립트 변경 사항에 대한 자세한 내용은 Splunk Enterprise의 Python 개발을 참조하십시오 .

Splunk provides the Splunk Platform Upgrade Readiness app for admins to scan deployed apps for any components impacted by migration to Python 3. For more information, see the Splunk Platform Upgrade Readiness App. Developers should also review all issues covered in this manual and test app and add-on revisions with the Splunk Enterprise version 8.0 before resubmitting to Splunkbase.

Splunk는 관리자가 Python 3으로 마이그레이션하여 영향을받는 구성 요소에 대해 배포 된 앱을 검색 할 수 있도록 Splunk 플랫폼 업그레이드 준비 앱을 제공합니다. 자세한 내용은 Splunk 플랫폼 업그레이드 준비 앱을 참조하십시오 . 또한 개발자는 Splunkbase에 다시 제출하기 전에이 매뉴얼에서 다루는 모든 문제를 검토하고 Splunk Enterprise 버전 8.0의 앱 및 애드온 개정판을 테스트해야합니다.

### Splunk solutions customers

Customers of some Splunk solutions must update ML models to support Python 3, as specified in Splunk IT Service Intelligence and Splunk Machine Learning Toolkit.

일부 Splunk 솔루션 고객은 Splunk IT 서비스 인텔리전스 및 Splunk Machine Learning Toolkit에 지정된대로 Python 3을 지원하도록 ML 모델을 업데이트해야합니다 .

>> This information is subject to change at any time, at the sole discretion of Splunk Inc. and without notice. This roadmap information shall not be incorporated into any contract or other commitment. Splunk undertakes no obligation to either develop or deliver any product, features, or functionality described here.
이 정보는 Splunk Inc.의 단독 재량에 따라 언제든지 예고없이 변경 될 수 있습니다. 이 로드맵 정보는 계약 또는 기타 약속에 포함되지 않습니다. Splunk는 여기에 설명 된 제품, 기능 또는 기능을 개발하거나 제공 할 의무가 없습니다.

## Changes to Splunk Enterprise

>> Check this manual often for updated information about the Splunk platform Python 3 migration. The content is subject to change.
Splunk 플랫폼 Python 3 마이그레이션에 대한 업데이트 된 정보는이 매뉴얼을 자주 확인하십시오. 내용은 변경 될 수 있습니다.

The following changes to Splunk Enterprise cause breaking changes to existing Python scripts:
Splunk Enterprise를 다음과 같이 변경하면 기존 Python 스크립트가 변경됩니다.

- Custom web controllers (such as CherryPy endpoints). Requires script-level compatibility with Python 3.7. Failure to make compatible with Python 3.7 may cause issues starting Splunk Web.
- Custom Mako templates. Requires script-level compatibility with Python 3.7. Failure to make compatible with Python 3.7 may cause issues starting Splunk Web.
- Advanced XML (deprecated in Splunk version 6.3): removed. If possible, replace Advanced XML with Simple XML. For more information about alternatives to Advanced XML available in Splunk Enterprise, see Building customizations for the Splunk platform.
- Splunk Web Legacy Mode (deprecated in Splunk version 6.4): removed. Do not set appServerPorts = 0 in web.conf.

- 사용자 정의 웹 컨트롤러(예 : CherryPy 엔드 포인트) Python 3.7과 스크립트 수준의 호환성이 필요합니다. Python 3.7과 호환되지 않으면 Splunk Web 시작 문제가 발생할 수 있습니다.
- 맞춤형 Mako 템플릿. Python 3.7과 스크립트 수준의 호환성이 필요합니다. Python 3.7과 호환되지 않으면 Splunk Web 시작 문제가 발생할 수 있습니다.
- 고급 XML (Splunk 버전 6.3에서 더 이상 사용되지 않음) : 제거되었습니다. 가능하면 Advanced XML을 Simple XML로 바꾸십시오. Splunk Enterprise에서 사용 가능한 Advanced XML의 대안에 대한 자세한 내용은 Splunk 플랫폼의 사용자 지정 구성을 참조하십시오 .
- Splunk Web 레거시 모드 (Splunk 버전 6.4에서 더 이상 사용되지 않음) : 제거되었습니다. 설정하지 마십시오 `appServerPorts = 0`에 web.conf .

For guidelines for updating Python scripts for compatibility with Python 3.7, see Python Code Compatibility. For Splunk Enterprise version 8.0 upgrade instructions, see Choose your Splunk Enterprise upgrade path for the Python 3 migration.

Python 3.7과의 호환성을 위해 Python 스크립트를 업데이트하기위한 지침은 Python 코드 호환성을 참조하십시오 . Splunk Enterprise 버전 8.0 업그레이드 지침 은 Python 3 마이그레이션을위한 Splunk Enterprise 업그레이드 경로 선택을 참조 하십시오 .

In addition to breaking changes and upgrade steps, a number of features and components will be impacted with the Splunk Enterprise version 8.0, but deployments can be migrated to Python 3.7 over time. The Splunk Enterprise Python 3 release will also include both Python 2.7 and Python 3.7 interpreters, with Python 2.7 enabled for all custom Python scripts outside of those shipped with Splunk Enterprise.
변경 및 업그레이드 단계를 중단하는 것 외에도 많은 기능과 구성 요소가 Splunk Enterprise 버전 8.0의 영향을 받지만 시간이지나면서 배포를 Python 3.7로 마이그레이션 할 수 있습니다. Splunk Enterprise Python 3 릴리스에는 Python 2.7 및 Python 3.7 인터프리터가 모두 포함되며 Splunk Enterprise와 함께 제공되는 스크립트 이외의 모든 사용자 지정 Python 스크립트에 Python 2.7을 사용할 수 있습니다.

The Python 2.7 interpreter will still be used by default in Splunk Enterprise version 8.0 for features that include:
Python 2.7 인터프리터는 Splunk Enterprise 버전 8.0에서 기본적으로 다음과 같은 기능을 위해 계속 사용됩니다.

- Custom search commands
- Custom REST endpoints
- Scripted authentication
- Scripted inputs
- Modular inputs
- Scripted lookups
- Custom alert actions
- Modular alerts
- Cold-to-frozen scripts

Note that scripted alerts were deprecated in version 6.3 and are not supported in Python 3.7. Convert any scripted alerts to custom alert actions in order to adopt Python 3.7.
스크립팅 된 경고는 버전 6.3에서 더 이상 사용되지 않으며 Python 3.7에서는 지원되지 않습니다. Python 3.7을 채택하려면 스크립트 된 경고를 사용자 정의 경고 조치로 변환하십시오.

Using Python 3-only syntax for these features might be incompatible with the Python 2.7 interpreter which will be enabled by default in the Splunk Enterprise version 8.0. Python scripts that are compatible with both Python 2 and Python 3 should work with either Python interpreter used by Splunk Enterprise, and is recommended for developers. For more information about making Python scripts dual-compatible, see Python Development in Splunk Enterprise.
이러한 기능에 Python 3 전용 구문을 사용하면 Splunk Enterprise 버전 8.0에서 기본적으로 활성화되는 Python 2.7 인터프리터와 호환되지 않을 수 있습니다. Python 2 및 Python 3과 호환되는 Python 스크립트는 Splunk Enterprise에서 사용하는 Python 인터프리터와 함께 작동해야하며 개발자에게 권장됩니다. Python 스크립트를 이중 호환 가능하게 만드는 방법에 대한 자세한 내용은 Splunk Enterprise의 Python 개발을 참조하십시오 .

### Splunk Web

Unlike the Splunk Enterprise version 8.0, Splunk Web will support only Python 3.7. Scripts that depend on Splunk Web (including custom CherryPy endpoints and Python in Mako templates) must be upgraded to use syntax compatible with both Python 2.7 and 3.7 to allow for upgrades to 8.0 from 7.x versions of Enterprise.
Splunk Enterprise 버전 8.0과 달리 Splunk Web은 Python 3.7 만 지원합니다. Splunk Web에 의존하는 스크립트 (커스텀 CherryPy 엔드 포인트 및 Mako 템플릿의 Python 포함)는 Python 2.7 및 3.7과 호환되는 구문을 사용하여 7.x 버전의 Enterprise에서 8.0으로 업그레이드 할 수 있도록 업그레이드해야합니다.

### Python interpreter settings

Splunk Enterprise version 8.0 include a global setting, python.version, to specify which Python interpreter to use across an instance. The global setting resides in the server.conf file, located in $SPLUNK_HOME/etc/system/local/. The stanza that controls Python version is [general]. For more information how Splunk Enterprise uses configuration files, see About configuration files.
Splunk Enterprise 버전 8.0에는 전역 설정을 포함 python.version하여 인스턴스에서 사용할 Python 인터프리터를 지정합니다. 전역 설정은에있는 server.conf 파일에 있습니다 $SPLUNK_HOME/etc/system/local/. Python 버전을 제어하는 ​​스탠자는입니다 [general]. Splunk Enterprise가 구성 파일을 사용하는 방법에 대한 자세한 내용은 구성 파일 정보를 참조하십시오 .

python.version is set to python2 by default in Splunk Enterprise version 8.0. To specify Python 3, set python.version = python3. These settings specify the interpreter to use if a script-level setting has not been specified, but script-level settings take precedence over the global setting, except if Python 3 is forced.
python.versionpython2Splunk Enterprise 버전 8.0에서는 기본적으로 설정되어 있습니다. Python 3을 지정하려면을 설정하십시오 python.version = python3. 이 설정은 스크립트 수준 설정이 지정되지 않은 경우 인터프리터를 지정하지만 Python 3이 강제 실행되는 경우를 제외하고는 스크립트 수준 설정이 전역 설정보다 우선합니다.

To force Splunk Enterprise to use only the Python 3 interpreter regardless of script-level setting, set python.version = force_python3. Use this setting if you cannot run Python 2.7 past its EOL date of January 1, 2020, or if your Splunk Enterprise deployment and all Splunk apps and add-ons are fully migrated and ready to run Python 3 only.
Splunk Enterprise가 스크립트 수준 설정에 관계없이 Python 3 인터프리터 만 사용하도록하려면을 설정하십시오 python.version = force_python3. 2020 년 1 월 1 일의 EOL 날짜 이후 Python 2.7을 실행할 수 없거나 Splunk Enterprise 배포 및 모든 Splunk 앱과 애드온이 완전히 마이그레이션되어 Python 3 만 실행할 준비가 된 경우이 설정을 사용하십시오.

Splunk Enterprise version 8.0 also includes python.version settings to control which version of the Python interpreter is used by Splunk Enterprise at the script-level. For the following scripts, the python.version setting resides in the corresponding conf file:
Splunk Enterprise 버전 8.0에는 python.version스크립트 수준에서 Splunk Enterprise가 사용하는 Python 인터프리터 버전을 제어하는 ​​설정 도 포함되어 있습니다. 다음 스크립트의 경우 python.version설정은 해당 conf 파일에 있습니다.

<table>
<tr><td>Script type</td><td>File</td></tr>
<tr><td>Custom search commands</td><td>commands.conf</td></tr>
<tr><td>Modular inputs</td><td>inputs.conf</td></tr>
<tr><td>Scripted inputs</td><td>inputs.conf</td></tr>
<tr><td>Custom alert actions</td><td>alert_actions.conf</td></tr>
<tr><td>Scripted lookups</td><td>transforms.conf</td></tr>
<tr><td>Custom REST endpoints</td><td>restmap.conf</td></tr>
<tr><td>Scripted authentication</td><td>authentication.conf</td></tr>
<tr><td>coldToFrozenScript</td><td>indexes.conf</td></tr>
</table>

By default, the script-level setting of python.version is not set, and the script will use the Python interpreter specified by the global setting in server.conf. Setting python.version to default or python also uses the Python interpreter specified by the global setting in server.conf. If set to python2 or python3, the corresponding Python interpreter will be used. This overrides the global setting, except if the global setting is force3, in which case Python 3 is always used.
기본적으로 스크립트 수준 설정은 설정되어 python.version있지 않으며 스크립트는 server.conf의 전역 설정으로 지정된 Python 인터프리터를 사용합니다. 설정 python.version에 default나 python또한 것은 server.conf에서 전역 설정에 의해 지정된 파이썬 인터프리터를 사용합니다. python2또는로 설정 python3하면 해당 Python 인터프리터가 사용됩니다. 전역 설정이 인 경우를 제외하고 전역 설정을 재정의합니다 force3.이 경우 Python 3이 항상 사용됩니다.

Setting python.version for coldToFrozenScript applies if the canonical path to the Python interpreter is used. However, note that for coldToFrozen:
Python 인터프리터에 대한 표준 경로가 사용되는 경우에 대한 설정 python.version이 coldToFrozenScript적용됩니다. 그러나 다음 사항에 유의하십시오 coldToFrozen.

>> scripts set executable on UNIX with a #! shebang line pointing to a valid interpreter.
Splunk 플랫폼 Python 3 마이그레이션에 대한 업데이트 된 정보는이 매뉴얼을 자주 확인하십시오. 내용은 변경 될 수 있습니다.

If your script is specified with #! /usr/bin/env python, then python.version will be ignored for coldToFrozen. Also note that for warmToCold, this is always how the Python script is specified, so there is no applicable python.version for warmToCold.
스크립트가 지정되어있는 경우 #! /usr/bin/env python, 다음 python.version무시됩니다 coldToFrozen. 또한 대한 점에 유의 warmToCold그래서 적용 할 수 없다, 이것은 파이썬 스크립트가 지정되어 항상 어떻게, python.version대한 warmToCold.

>> Check this manual often for updated information about the Splunk platform Python 3 migration. The content is subject to change.
Splunk 플랫폼 Python 3 마이그레이션에 대한 업데이트 된 정보는이 매뉴얼을 자주 확인하십시오. 내용은 변경 될 수 있습니다.

### Search and Reporting

If you have modified Splunk Search and Reporting with scripts or other customizations using Python 2, you must update these scripts to use Python 3 syntax or to be dual-compatible with both Python 2 and Python 3.
Python 2를 사용하여 스크립트 또는 기타 사용자 지정으로 Splunk 검색 및보고를 수정 한 경우 Python 3 구문을 사용하거나 Python 2 및 Python 3과 이중 호환 가능하도록이 스크립트를 업데이트해야합니다.

If you must maintain Python 2 compatibility, use Python compatibility libraries provided with Splunk Enterprise to help make apps and add-ons compatible with both Python 2 and Python 3. (Six, Python-future, 2to3). Splunk also updated Splunk Enterprise 7.x maintenance releases to include these Python compatibility libraries. These Splunk-provided libraries should not be used for any other apps; all custom or Splunkbase apps should package their own libraries to respect app structures.
Python 2 호환성을 유지해야하는 경우 Splunk Enterprise와 함께 제공되는 Python 호환성 라이브러리를 사용하여 앱 및 애드온을 Python 2 및 Python 3 (6, Python-future, 2to3)과 호환되도록하십시오. 또한 Splunk는 이러한 Python 호환성 라이브러리를 포함하도록 Splunk Enterprise 7.x 유지 관리 릴리스를 업데이트했습니다. 이러한 Splunk 제공 라이브러리는 다른 앱에 사용해서는 안됩니다. 모든 사용자 정의 또는 Splunkbase 앱은 앱 구조를 존중하기 위해 자체 라이브러리를 패키지해야합니다.

### Analytics for Hadoop and Hadoop Data Roll

Analytics for Hadoop and Hadoop Data roll do not support Python 3 in Splunk Enterprise version 8.0.0. When using Hadoop with Splunk Enterprise:
Hadoop 및 Hadoop 데이터 롤 분석은 Splunk Enterprise 버전 8.0.0에서 Python 3을 지원하지 않습니다. Splunk Enterprise와 함께 Hadoop을 사용하는 경우 :

- Do not set set python.version = python3 for the global python.version setting, which resides in the server.conf file.
- Do not remove the Python 2.7 runtime. If your deployment requires the removal of - Python 2.7 for for security compliance reasons, contact Splunk Support.
server.conf 파일 python.version = python3에있는 전역 python.version설정에 대해서는 set을 설정하지 마십시오 .
- Python 2.7 런타임을 제거하지 마십시오. 보안 준수를 위해 배포시 Python 2.7을 제거해야하는 경우 Splunk 지원에 문의하십시오.

### Splunk Platform Upgrade Readiness app

Splunk provides the Splunk Platform Upgrade Readiness app for admins to scan deployed apps for any components impacted by migration to Python 3. The app is recommended to prepare for an upgrade to Splunk Enterprise version 8.0. For more information, see the Splunk Platform Upgrade Readiness App.
Splunk는 관리자가 Python 3으로 마이그레이션하여 영향을받는 구성 요소에 대해 배포 된 앱을 검색 할 수 있도록 Splunk 플랫폼 업그레이드 준비 앱을 제공합니다.이 앱은 Splunk Enterprise 버전 8.0으로의 업그레이드를 준비하는 것이 좋습니다. 자세한 내용은 Splunk 플랫폼 업그레이드 준비 앱을 참조하십시오 .

### Splunkbase apps and add-ons

After Splunk Enterprise version 8.0, impacted Splunkbase apps and add ons must be resubmitted to Splunkbase after validation of compatibility with the Splunk Enterprise version 8.0, including Python 3 testing with AppInspect. Apps that are marked compatible with Splunk Enterprise 7.x and below are Python 2.7-compatible only, while apps that are marked compatible with Splunk Enterprise 8.0 are Python 3.7-compatible only. Apps that are marked compatible with Splunk Enterprise 7.x and 8.0 are compatible with both Python 2.7 and 3.7.
Splunk Enterprise 버전 8.0 이후에는 AppInspect를 사용한 Python 3 테스트를 포함하여 Splunk Enterprise 버전 8.0과의 호환성을 검증 한 후 영향을받은 Splunkbase 앱 및 애드온을 Splunkbase에 다시 제출해야합니다. Splunk Enterprise 7.x 이하와 호환되는 것으로 표시된 앱은 Python 2.7 과만 호환되는 반면 Splunk Enterprise 8.0과 호환되는 것으로 표시된 앱은 Python 3.7과 호환됩니다. Splunk Enterprise 7.x 및 8.0과 호환되는 것으로 표시된 앱은 Python 2.7 및 3.7과 모두 호환됩니다.

## Python development with Splunk Enterprise

>> Check this manual often for updated information about the Splunk platform Python 3 migration. The content is subject to change.
Splunk 플랫폼 Python 3 마이그레이션에 대한 업데이트 된 정보는이 매뉴얼을 자주 확인하십시오. 내용은 변경 될 수 있습니다.

The migration to Python 3 impacts Python scripts developed by Splunk app and add on developers and admins. In addition to changes to Python scripts, there are additional settings for Splunk administrators and prerequisites for upgrading to Splunk Enterprise version 8.0. For more information, see Changes to Splunk Enterprise. For Splunk Enterprise version 8.0 upgrade instructions, see Choose your Splunk Enterprise upgrade path for the Python 3 migration.

Python 3으로의 마이그레이션은 Splunk 앱에서 개발 한 Python 스크립트에 영향을 미치며 개발자와 관리자를 추가합니다. Python 스크립트 변경 외에도 Splunk 관리자 및 Splunk Enterprise 버전 8.0으로 업그레이드하기위한 전제 조건에 대한 추가 설정이 있습니다. 자세한 내용은 Splunk Enterprise 변경 사항을 참조하십시오 . Splunk Enterprise 버전 8.0 업그레이드 지침 은 Python 3 마이그레이션을위한 Splunk Enterprise 업그레이드 경로 선택을 참조 하십시오 .

Developers must update Python scripts used in apps and add-ons for compatibility with Splunk Enterprise version 8.0. For guidelines for updating Python scripts in general, see Python Code Compatibility.
개발자는 Splunk Enterprise 버전 8.0과의 호환성을 위해 앱 및 애드온에 사용되는 Python 스크립트를 업데이트해야합니다. 일반적으로 Python 스크립트 업데이트에 대한 지침은 Python 코드 호환성을 참조하십시오 .

The following Splunk Enterprise features will require script-level compatibility with Python 3.7:
다음 Splunk Enterprise 기능을 사용하려면 Python 3.7과 스크립트 수준의 호환성이 필요합니다.

- Custom web controllers (such as CherryPy endpoints)
- Custom Mako templates
- 사용자 정의 웹 컨트롤러 (예 : CherryPy 엔드 포인트)
- 커스텀 Mako 템플릿

These must be made dual-compatible with both Python 2 and 3 to prevent breakage for customers upon upgrade.
업그레이드시 고객의 파손을 막기 위해 Python 2 및 3과 이중 호환 가능해야합니다.

Splunk Enterprise provides settings to specify which Python interpreter to use at global and script levels, covered in Changes to Splunk Enterprise.
Splunk Enterprise는 Splunk Enterprise 변경 사항 에서 다루는 전역 및 스크립트 수준에서 사용할 Python 인터프리터를 지정하는 설정을 제공합니다

### Removal of deprecated Splunk platform features

Some deprecated features have been removed from Splunk Enterprise version 8.0, which might require file revisions:
더 이상 사용되지 않는 일부 기능이 Splunk Enterprise 버전 8.0에서 제거되어 파일 수정이 필요할 수 있습니다.

- Advanced XML (deprecated in Splunk version 6.3). If possible, replace Advanced XML with Simple XML. For more information about alternatives to Advanced XML available in Splunk Enterprise, see Building customizations for the Splunk platform.
- Splunk Web Legacy Mode (deprecated in Splunk version 6.4): do not set appServerPorts = 0 in web.conf.
- 고급 XML (Splunk 버전 6.3에서 사용되지 않음). 가능하면 Advanced XML을 Simple XML로 바꾸십시오. Splunk Enterprise에서 사용 가능한 Advanced XML의 대안에 대한 자세한 내용은 Splunk 플랫폼의 사용자 지정 구성을 참조하십시오 .
- Splunk 웹 레거시 모드 (Splunk 버전 6.4에서 더 이상 사용되지 않음) : web.confappServerPorts = 0 에서 설정하지 마십시오 .

### Writing scripts compatible with Python 2 and Python 3

Developers must make all Python files and scripts compatible with Python 3 to be compatible with Splunk Enterprise version 8.0. When making apps and scripts compatible with Python 3, Splunk recommends writing dual-compatible Python code that works with both Python 2 and Python 3 interpreters. For more information about Python compatibility libraries, see Python Code Compatibility.
개발자는 Splunk Enterprise 버전 8.0과 호환되도록 모든 Python 파일 및 스크립트를 Python 3과 호환 가능하게 만들어야합니다. Python 3과 호환되는 앱 및 스크립트를 만들 때 Splunk는 Python 2와 Python 3 인터프리터 모두에서 작동하는 이중 호환 Python 코드를 작성하는 것이 좋습니다. Python 호환성 라이브러리에 대한 자세한 내용은 Python 코드 호환성을 참조하십시오 .

Apps that must be written in Python 3-only syntax should set python.version to python3 in the appropriate .conf files for individual scripts. Developers should not set python.version in server.conf, nor set python.version in any .conf files for apps that are dual-compatible with Python 2 and 3. For more information about python.version settings, see Changes to Splunk Enterprise.
파이썬 3 전용 구문으로 작성해야 앱은 설정해야합니다 python.version에 python3개별 스크립트에 대한 적절한의 .conf 파일입니다. 개발자가 설정 안 python.version에 server.conf,도 설정 python.version파이썬 2 듀얼 호환, 3에 대한 자세한 내용은있는 앱에 대한 모든의 .conf 파일에 python.version, 설정 참조 인 Splunk Enterprise에 변경.

### Running against earlier indexer tiers

For apps that might run against a Splunk Enterprise version 7.3.x or earlier indexer tier, admins should ensure those apps use dual-compatible Python syntax. This is because custom search commands and scripted lookups will be passed to the indexer tier as part of the knowledge bundle, and any Python 3-specific syntax will fail on the indexer.
Splunk Enterprise 버전 7.3.x 또는 이전 버전의 인덱서 계층에 대해 실행될 수있는 앱의 경우 관리자는 해당 앱이 이중 호환 Python 구문을 사용하도록해야합니다. 사용자 지정 검색 명령 및 스크립트 조회가 지식 번들의 일부로 인덱서 계층으로 전달되고 인덱서에서 Python 3 관련 구문이 실패하기 때문입니다.

### Module naming conflicts

You should also rename any files that conflict with Python standard modules or Splunk libraries, such as files named test.py. Use different, non-reserved names to avoid namespace conflicts in Python 3.
Python 표준 모듈 또는 Splunk 라이브러리 (예 :)와 충돌하는 파일의 이름도 바꿔야합니다 test.py. Python 3에서 네임 스페이스 충돌을 피하려면 예약되지 않은 다른 이름을 사용하십시오.

### Splunk SDK for Python

The Splunk SDK for Python API and service wrappers are dual-compatible with Python 2 and Python 3, starting with version 1.6.5. Upgrade to the latest version of the Splunk SDK for Python to help make scripts that use the Splunk SDK for Python compatible with the Splunk Enterprise version 8.0.
파이썬에 대한 인 Splunk SDK API 및 서비스 래퍼 버전 1.6.5로 시작, 듀얼 호환 파이썬 2와 파이썬 3입니다. Python 용 Splunk SDK를 사용하는 스크립트가 Splunk Enterprise 버전 8.0과 호환되도록하려면 최신 버전의 Python 용 Splunk SDK로 업그레이드하십시오.

### Identifying Python scripts

Splunk provides the Splunk Platform Upgrade Readiness app for admins to scan deployed apps for any components impacted by migration to Python 3. For more information, see the Splunk Platform Upgrade Readiness App.
Splunk는 관리자가 Python 3으로 마이그레이션하여 영향을받는 구성 요소에 대해 배포 된 앱을 검색 할 수 있도록 Splunk 플랫폼 업그레이드 준비 앱을 제공합니다. 자세한 내용은 Splunk 플랫폼 업그레이드 준비 앱을 참조하십시오 .

You can also manually identify possibly impacted Python scripts in your app or deployment by taking the following steps:
다음 단계를 수행하여 앱 또는 배포에서 영향을 줄 수있는 Python 스크립트를 수동으로 식별 할 수도 있습니다.

- Identify files ending in *.py.
- Identify files in $SPLUNK_HOME/etc/apps/$<app_name>/bin/. These are typically custom scripts or inputs, which might not necessarily end in *.py. but can still be implicitly executed by the Python interpreter used by Splunk Enterprise.
- Identify any other files explicitly executed by the Python interpreter. These files are often executed by the command splunk cmd python $<script_name>.py. These files could contain shell scripts or could exist outside an app's or deployment's standard directories.
- 끝나는 파일 식별 *.py.
- 에서 파일을 식별하십시오 `$SPLUNK_HOME/etc/apps/$<app_name>/bin/`. 이것들은 일반적으로 사용자 정의 스크립트 또는 입력이며, 반드시 끝나지 않을 수도 *.py.있지만 Splunk Enterprise에서 사용하는 Python 인터프리터에 의해 암시 적으로 실행될 수 있습니다.
- Python 인터프리터가 명시 적으로 실행 한 다른 파일을 식별하십시오. 이러한 파일은 종종 명령으로 실행됩니다 `splunk cmd python $<script_name>.py`. 이러한 파일은 쉘 스크립트를 포함하거나 앱 또는 배포의 표준 디렉토리 외부에 존재할 수 있습니다.

### Splunk Web(1)

Unlike the rest of Splunk Enterprise version 8.0, Splunk Web will support only Python 3.7. Scripts that depend on Splunk Web (including custom CherryPy endpoints and Python in Mako templates) must be upgraded to be compatible with both Python 2 and Python 3 to allow for simpler upgrades.
나머지 Splunk Enterprise 버전 8.0과 달리 Splunk Web은 Python 3.7 만 지원합니다. Splunk Web에 의존하는 스크립트 (커스텀 CherryPy 엔드 포인트 및 Mako 템플릿의 Python 포함)는보다 간단한 업그레이드를 위해 Python 2 및 Python 3과 호환되도록 업그레이드해야합니다.

## Python Code Compatibility

Check this manual often for updated information about the Splunk platform Python 3 migration. The content is subject to change.
Splunk 플랫폼 Python 3 마이그레이션에 대한 업데이트 된 정보는이 매뉴얼을 자주 확인하십시오. 내용은 변경 될 수 있습니다.

To revise apps for compatibility with Splunk Enterprise version 8.0, Python code should generally be made compatible with Python versions 2 and 3, both. To accomplish this, developers should include Python compatibility libraries as needed, in this order of recommended use:
Splunk Enterprise 버전 8.0과의 호환성을 위해 앱을 수정하려면 Python 코드는 일반적으로 Python 버전 2 및 3과 호환 가능해야합니다. 이를 위해 개발자는 권장되는 순서대로 필요에 따라 Python 호환성 라이브러리를 포함시켜야합니다.

- Six
- Python-future
- 2to3

See the documentation for these libraries to use them to help make your Python scripts compatible with both Python 2 and Python 3. However, these libraries might not fully produce fully-compatible results, so here are a number of tips for updating scripts by hand to complete the transition to 2/3 compatible Python code.
이 스크립트를 사용하여 Python 스크립트를 Python 2 및 Python 3과 호환 가능하게 만드는 데 사용하려면이 라이브러리의 설명서를 참조하십시오. 그러나 이러한 라이브러리는 완전히 호환되는 결과를 생성하지 못할 수 있으므로 직접 스크립트를 업데이트하기위한 여러 가지 팁이 있습니다. 2/3 호환 파이썬 코드로의 전환을 완료하십시오.

- Fundamental tips
- Strings
- Integers
- Dictionaries and collections
- Sorting
- Modules
- Other tips

### Fundamentals

#### Current Python version

Many patterns work in both Python 2 and Python 3. However, to write code that differs between Python 2 and Python 3, determine which version of the interpreter is being used with this code:

```python
import sys
if sys.version_info >= (3, 0):
   print("version 3.x")
else:
   print("version 2.x")
```

Also, check the stanza-level Python-version settings of your scripts, combined with the admin-level Python-version setting in server.conf. For more information about stanza- and global-level Python version settings, see Changes to Splunk Enterprise.

#### Indentation

Python 3 has different indentation rules, and mixing tabs and spaces can cause problems. For best cross-compatibility, follow PEP8 and use space indentation only. For more information, see the PEP 8 Style Guide.

#### Print output

In Python 3, print() is now a function instead of a statement. For Python 2, do not use print statements. You can enable the print function by including as one of the first imports:

```python
from __future__ import print_statement
```

In Python 2, you could cause print to not print a new line by putting a trailing comma on the argument list. For Python 2/3 compatible code, use std.stdout.write() instead. In Python 2, you could use print >>handle "foo" but for Python 2/3 compatible code, instead use handle.write("foo\n").

### Strings

Handling strings properly is important when writing cross-compatible Python code. For the purpose of this discussion, in Python there are three types of string:

- native strings (default) – for example, "abc"
- binary strings – for example, b"abc"
- unicode strings – for example, u"abc"

In Python 2, a native, default string is a binary or "bytes" string. In Python 3, a native string is instead a unicode string. Python 3 is strict about not mixing different types of strings. Often, an explicit conversion is needed or a runtime error is produced.

In Python 2, default and binary strings shared the same type but iIn Python 3, you now must keep the two string types distinctly separated. Binary data should not be stored in a default string since Python 3 defaults to unicode strings, not binary.

Using strings effectively in Python 3 is a matter of knowing which type of data is contained in a string, and when strings must be converted between types.

#### Strategies for strings

In small, self-contained scripts, native strings might be avoided, but that's not likely in large, extensible projects. You might want to just use Python 2's unicode() everywhere, or from python-future use from builtins import str which, in Python 2.7, can cause problems. Changing the normal behavior of native strings might work inside a single script, but not likely when interfacing with larger systems.

For both Python 2 and 3, the native default string is by far the most common. The most effective strategy is usually to explicitly reference native strings and binary/bytes strings. Then, only when running on Python 3, use explicit conversions where needed.

For more tips about Python strings, including use of io.StringIO, see Other Tips later in this topic.

#### Different string types

Here are examples of default strings:

- "normal strings" including with r"raw escaping"
- I/O done with files like open("filename.ext", "r")
- I/O streams from StringIO

Here are examples of binary/bytes strings:

- b"bytes strings" including with br"raw escaping". Note, Python 3 also accepts rb"xxx" but only br"xxx" is portable to Python 2.
- I/O done with files like open("filename.ext", "rb")
- I/O streams from io.BytesIO
- data passed via stdin/stdout/stderr using subprocess.PIPE when running external processes
- data passed to APIs like hashlib.sha1(bytes)
- data accepted and returned by base64.b64encode(bytes)
- data produced by pickle, pack(), and similar functions

Most string operations are available on either type. However, the result of an operation will be the same type as the starting string:

```python
>>> "a,b,c".split(',')
['a', 'b', 'c']

>>> b"a,b,c".split(b',')
[b'a', b'b', b'c']
```

This applies to regular expressions; if you compile a regex pattern for a bytes string, the result is a pattern which can be used on bytes input.

You cannot directly mix the types of strings:

```python
>>> "a" + b"b"
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: can only concatenate str (not "bytes") to str
```

#### Converting between string types

When a string must transition between default string and a bytes string, use decode() and encode(). decode() takes a bytes string and returns a native string by decoding the bytes, which determines which unicode values the stream of bytes represents.

```python
>>> b"\x61\xc3\xa4\x61".decode()
'aäa'
```

encode() takes a default-string and returns a bytes string. It encodes individual unicode characters into the bytes needed to represent them. Both of these methods can take an encoding parameter, but default to UTF-8 which is usually appropriate.

When writing cross-compatible code, typically perform these conversions when specifically in Python 3. In Python 2, conversion methods exist, but convert between default strings and unicode strings. Typically in Python 2, default strings are used to hold both types of data, so it's best to keep them unconverted. An example of typical cross-compatible code for conversions is:

```python
process = subprocess.Popen(['cal'], stdout=subprocess.PIPE)
out, _ = process.communicate()
if sys.version_info >= (3, 0):
   out = out.decode()
print("result: " + out)
```

In short, always determine which data should be in strings or bytes, and only convert at the minimal boundaries between the two types.

#### Errors

When converting existing Python 2 code to cross-compatibility with Python 3, it's common to find a string operation fail on a type error. A common mistake when converting is to add encode() or decode() calls until it "works." This can quickly become a source of hidden bugs. When you have an error caused by incorrect mixing of string and binary data, ask two questions:

- Which type should the result be?
- Where does the value that isn't of the right type come from – and why is it in the other type?

Often, a single conversion of data to the correct type can avoid many later conversions. Change the mode of opening a binary file from "r" to "rb" (which is also accepted by Python 2). Convert a string early to the correct type rather than at the point of <codeTypeError exceptions.

In Python 3, a native string can't hold arbitrary binary data; only a bytes string can do so. If you don't have binary data in the right type of string to start, it will cause errors even if you use encode() every time you use the string.

Finally, in Python 2, "abc" and b"abc" are equivalent. If the error you are getting in Python 3 involves a string constant operand being the wrong type, it's often the solution to simply mark the string constant as a b"bytes string".

#### Additional tips

- Don't test for types against isinstance(x, basestring). If you must check that something is a "normal" string, use isinstance(x, splunk.util.string_type) instead.
- If Python 2 code is specifically expecting a u"unicode" string, use splunk.util.unicode() as a replacement.

```python
s = unicode("abc")  # BEFORE
s = splunk.util.unicode("abc")  # AFTER
```

`json.loads()` can accept either type of string. However, XML APIs like `safe_lxml.fromstring()` should use bytes stringinput in Python 3. They can accept simple XML in either format, but if the XML document contains an header, then the XML layer will try to perform unicode decoding and will fail if input is already unicode.

### Integers

#### Integer division

In Python 2, normal integer division returned the integer part of the result. For example, `7/2 == 3` was true. Expressions like `x[0:len(x)/2]` were valid. In Python 3, this is no longer true; integer division returns the fractional part also.

One way to return just the integer result is to use the // operator, explicitly an integer division. This operator is also available in Python 2.7. Another option is to convert the result into an int, such as int(x/2).

#### floor() and ceil()

In Python 2, `math.floor()` and `math.ceil()` both returned a float type result. In Python 3, they return an int type result.

#### No long type

In Python 2, there were two integer types: int and long, which were used depending on the size of the integer. In Python 3, only int exists and it handles either numeric range automatically. Numeric constants that are explicitly long, such as 123L must be revised to simply 123.

#### Octal constants

In Python 3, octal integer constant can no longer be experessed in the form 0123. The more explicit form 0o123 works both in Python 2.7 and Python 3.

### Python exceptions

An important difference is that some older exception syntax that was accepted by Python 2.7 now an produces an error in Python 3.

Replace any statements like:

```python
raise MyException, "msg"
```

With the Python 3 form:

```python
raise MyException("msg")
```

Also, replace:

```python
except MyException, ex:
```

With:

```python
except MyException as ex:
```

#### ex.message

In Python 3, exception objects no longer have a .message attribute. One way to get the message component of an exception is with str(ex).

However, for the exact object that ex.message provided in Python 2, use ex.args[0].

This works in both Python 2.7 and Python 3.x.

#### StopIteration

Generator functions should not explicitly throw StopIteration. Rather, they should return when they are finished, instead of yielding. In Python 3.7, an explicitly thrown StopIteration produces a runtime error.

### Dictionaries and other collections

The following changes apply to dict and other collection types:

- dict no longer has the has_key() method. Replace:

```python
if d.has_key("x"):
```

With:

```python
if "x" in d: (works in 2.x and 3.x)
```

- In Python 3, dict.keys() and dict.values() no longer directly return lists. Instead, they return objects of type dict_keys and dict_values, respectively. These objects can still be iterated normally, but sometimes code that depends a list now requires explicit conversion. Replace:

```python
l = d.keys() + [ "extra" ]  # BEFORE
```

With:

```python
l = list(d.keys()) + [ "extra" ]  # AFTER
```

- Don't use .iteritems(), .iterkeys(), or .itervalues(). Rather, iterate on .items(), .keys(), or .values() directly.
- Instead of calling iter.next() on an iterator, use the next(iter) function. The associated method to override this function for your own classes is __next__(self).

### Sorting

The in-place lst.sort() method is deprecated. Instead, use the portable lst = sorted(lst) instead, at least where support for older versions of Python 2 isn't required. sorted() works fine on Python 2.7, however.

sorted() (and sort()) no longer take a cmp parameter. Instead, if you are just using cmp= to sort on an attribute of each element, it's usually simple to convert to the portable key parameter. Replace:

```python
x.sort(cmp = lambda a, b: cmp(a.meth(), b.meth()))  # BEFORE
```

With:

```python
x = sorted(x, key = lambda e: e.meth())  # AFTER
```

This form works in Python version 2.4 and later.

If the cmp parameter is more complicated, use the cmp_to_key() function from the functools package. Replace:

```python
x = sorted(x, cmp = my_fancy_compare_function) #BEFORE
```

with

```python
x = sorted(x, key = functools.cmp_to_key(my_fancy_compare_function)) # AFTER
```

Convert any "hidden" cmp parameters. They are not always passed in as named parameters, as in (x.sort(my_cmp_function)).

The top-level cmp(a, b) operator isn't available in Python 3. Either rewrite your code not to require it, or consider using the replacement function from the splunk.util package (if your code only must function in Splunk 8.0 and later).

Classes that define a custom __cmp__() method in Python 2 should instead define both __eq__() and __lt__() methods. They can use the @total_ordering decorator 
from functools:

```python
from functools import total_ordering
@total_ordering
class MyObject(object):
# [...]
   def __eq__(self, other):
       return self._i == other._i
   def __lt__(self, other):
       return self._i < other._i
```

### Module-specific advice

Many common Python modules have been reorganized in Python 3. Often, common functionality can be accessed in ways that are portable to both Python 2 and Python 3. Also, don't use the syntax from package import *. Instead, specify the subpackages needed.

#### StringIO and cStringIO

In Python 3, this module has moved to io.StringIO. Python 2 also has an io.StringIO library, which forces u"unicode" strings. For native/"default" strings under both Python 2 and Python 3, this often causes problems. One fix:

```python
import sys
if sys.version_info >= (3, 0):
   from io import StringIO
else:
   from StringIO import StringIO
```

As covered in Strings, in Python3, normal strings and bytes/binary aren't the same. For binary data, use the io.BytesIO object instead:

```python
msg = b"Bytes I want to treat like a file"
if sys.version_info >= (3, 0):
   fh = io.BytesIO(msg)
else:
   fh = StringIO(msg)
```

cStringIO is gone in Python 3. Use StringIO as above. This is a bit slower in Python 2, but faster in Python 3.

#### httplib

httplib is http.client in Python 3:

```python
try:
   import http.client as httplib
except ImportError:
   import httplib
```

#### urlparse

urlparse is now urllib.parse in Python 3. From Six, you can use six.moves.urllib:

```python
from six.moves.urllib import parse as urllib_parse
```

Or, from pyton-future, Six, you can use future.moves:

```python
from future.moves.urllib import parse as urllib_parse
```

Then call urllib_parse.urlparse(), .parse_qs(), .urlsplit(), .urlunsplit(), and so on.

If you need just a small number of methods, you can probe directly:

```python
try:
   from urllib.parse import urlparse
except ImportError:
   from urlparse import urlparse
```

#### urllib2

urllib2 is gone in Python 3, with most of its functionality moved to various sub-classes. Usually, convert using the six or python-future equivalents. For example, from future.moves:

```python
from future.moves.urllib.request import urlopen, Request
from future.moves.urllib.error import HTTPError

try:
   req = Request(url);
   res = urlopen(req);
except HTTPError as e:
   sys.stderr.write("nope!\n");
```

You can also import full packages from future.moves:

```python
from future.moves.urllib import error as urllib_error
from future.moves.urllib import request as urllib_request
```

#### Cookie

Cookie is now http.cookies in Python 3.

```python
try:
   from http.cookies import SimpleCookie
except ImportError:
   from Cookie import SimpleCookie
```

#### cPickle

cPickle is removed from Python 3.

#### string

string is removed from Python 3. Mostly, string functions have become methods on str:

```python
x = string.strip(y)  # BEFORE
x = y.strip()  # AFTER
lst = string.split(y, ',')  # BEFORE
lst = y.split(',')  # AFTER
```

This style works in both Python 2 and Python 3.

#### queue

Queue is renamed to queue in Python 3. Most Python 2 functionality is retained with:

```python
try:
   import queue
except ImportError:
   import Queue as queue
```

#### thread

thread has been removed in Python 3. Some internals are available as _thread:

```python
try:
   import _thread as thread
except ImportError:
   import thread
```

#### UserDict

In Python 3, UserDict is now part of collections:

```python
try:
   from collections import UserDict
except ImportError:
   from UserDict import UserDict
```

##### contextlib.nested

contextlib.nested() is removed from Python 3. Use a list with the with statement:

```python
with contextlib.nested(open("a"), open("b")) as (fh_a, fh_b):  # BEFORE
with open("a") as fh_a, open("b") as fh_b:  # AFTER
```

#### ConfigParser

In Python 3, ConfigParser has been renamed configparser. However, this is not a direct library change, but an overhaul of ConfigParser. One of the biggest differences is the default key/value delimitiers, which are = and :. ConfigParser defaulted to =. Many Splunk .cfg and .conf files assume : is not a delemiter.

Duplicates is another default of configparser that differs from ConfigParser. ConfigParser allowed duplicates by default, but configparser throws exceptions on duplicates by default. There are many cases of .cfg and .conf files with duplicates, and the parameter that controls this is strict.

For compatibility with Python 2 and 3 when using configparser, create instances with the following:

```python
configparser.ConfigParser(delimiters=('='), strict=False)
```

#### Other changes

The following additional changes also apply to Python code to be made compatible with both Python 2 and 3:

- In Python 3, xrange() is removed. If the range is not too large, use range(). In Python 2, range() is available but slower than xrange(). In Python 3, range() is faster.
- In Python 3, file() is no longer callable as a function. Use the open() function instead with the same parameters. open() is available in Python 2, also.
- In Python 3, os.path.walk() is removed. Convert code to use the portable os.walk() instead.
- In Python 3, classes should not directly assign __metaclass__:

1. BEFORE:

```python
class MyClass(object):
    __metaclass__ = SomeOtherObject
# AFTER:
from future.utils import with_metaclass
class MyClass(with_metaclass(SomeOtherObject, object)):
```

- In Python 3, rawinput() is removed. Use input() instead. If your code needs to work the same in Python 2 and Python 3, use:

```python
if sys.version_info >= (3, 0):
    response = input("Prompt: ")
else:
    response = raw_input("Prompt: ")
```

- In Python 3, execfile() is removed. Use exec(open(file).read()) instead.
- In Python 3, exec "code" in global_map is removed. Python 3 and Python 2 both accept exec("code", global_map) instead.
- In Python 3, reduce() has been moved to the functools module:

```python
import functools
functools.reduce(lambda x, y: x + y, [47, 11, 42, 13])
```

## Splunk Cloud

Check this manual often for updated information about the Splunk platform Python 3 migration. The content is subject to change.

Splunk Cloud will support the Splunk Enterprise version 8.0 and will also continue to support prior versions of Splunk Enterprise 7.x, which support Python 2.7. Splunk will upgrade all supported apps vetted for Splunk Cloud as soon as they can be made available.

### App submission

Apps vetted for Splunk Cloud must be resubmitted for new Splunk Cloud vetting after the app has been made Python 3-compatible. You can make apps Python 3-compatible by revising scripts impacted by Python 3 migration and removing features no longer supported.

Ensure that private apps and Splunkbase apps are compatible with both Splunk Enterprise version 7.x and version 8.0 before submitting them for installation.

Apps for Splunk Cloud will follow the same guidelines as on-premises apps, with the added requirement of passing Splunk Cloud vetting.

## Python with Splunk Enterprise Security

Enterprise Security (ES) version 5.3.x and earlier are compatible with Python 2 only. ES version 6.0.x begins the transition to Python 3, but is not completely dual compatible with Python 2 and Python 3. ES version 6.1.x is compatible with Python 3 only.

For more information about Splunk ES, see Splunk Enterprise Security Release Notes.

### Splunk Enterprise Security version 5.3.x and Python compatibility

Splunk Enterprise Security versions 5.3.1 and earlier are not compatible with Splunk Enterprise version 8.0 and Python 3.

### Splunk Enterprise Security version 6.0.x and Python compatibility

Splunk Enterprise Security version 6.0.x is compatible with Splunk Enterprise version 8.0, though it currently requires the Python 2 interpreter that ships with Splunk Enterprise 8.0. The following flag is available in the ES 6.0.x specification files:

```properties
python.version = {default|python|python2|python3}
```

However, ES 6.0.x is not completely dual Python 2 and Python 3 compatible. Various configuration files are set python.version = python2 on purpose. Do not set these flags to python3 or run in strict python3 mode at this time.

Enterprise Security 6.0.x is the last major release that is compatible with Python 2 and with Machine Learning Toolkit 4.0.

### Splunk Enterprise Security version 6.1.x and Python compatibility

Splunk Enterprise Security version 6.1.x is compatible with Splunk Enterprise version 8.0. The following flag is available in the ES 6.1.x specification files:

```properties
python.version = python3
```

ES 6.1.x is Python 3 compatible only. Various configuration files are set python.version = python3 on purpose. Do not change these flags at this time.

ES 6.1.x is compatible with Machine Learning Toolkit 5.0 and above only. The previously generated models from MLTK 4.x are not compatible and have to be regenerated. See Update Splunk MLTK models for Python 3 for information about rebuilding models.

## Python 3 migration with ITSI

This page helps identify prerequisites, required changes, and steps for migrating ITSI to Python 3 alongside your Splunk Enterprise deployment. This topic covers the following upgrade scenarios:

- Migrating ITSI and Splunk Enterprise to Python 3
- Upgrading to Splunk Enterprise version 8.0.0 with Python 2
- Upgrading to ITSI 4.4.0 without upgrading to Splunk Enterprise version 8.0.0

### Scenario 1: Migrate ITSI to Python 3

>> You must upgrade ITSI and all other associated add-ons to the newest versions before upgrading to Splunk Enterprise version 8.0.0. If you upgrade Splunk Enterprise first, ITSI breaks.

In order to upgrade to Splunk Enterprise 8.0.0, you must also upgrade to ITSI version 4.4.0. All ITSI versions prior to 4.4.0 are incompatible with Splunk Enterprise version 8.0.0, even if you use the Python 2.7 runtime. For more information about ITSI compatibility with Splunk Enterprise, see the Splunk products version compatibility matrix.

The only post-upgrade impact for Python 3 migration relates to ITSI Predictive Analytics customers. If you currently leverage ITSI's Predictive Analytics capabilities, you must retrain all of your predictive models after you migrate ITSI to Python 3. For information about Predictive Analytics, see Predict and prevent outages with ITSI Predictive Analytics.

Perform the following steps in this order to migrate ITSI to Python 3. Some steps are only required if you're using Predictive Analytics.

#### Step 1: Upgrade to ITSI version 4.4.0

Upgrade to ITSI version 4.4.0. For more information, see Upgrade IT Service Intelligence on a single instance or Upgrade IT Service Intelligence in a search head cluster environment depending on your deployment architecture.

#### Step 2: Upgrade the Machine Learning Toolkit

If you're using Predictive Analytics, upgrade your MLTK to version 5.0.0 or later.

#### Step 3: Upgrade required add-ons

If you have an integration with ServiceNow and/or leverage ITSI's bidirectional ticketing functionality, you must upgrade the Splunk Add-on for ServiceNow and the Common Information Model (CIM) to the newest releases which are Python 3 compatible.

- Upgrade the Splunk Add-on for ServiceNow to version 5.0.0. For instructions, see Upgrade the Splunk Add-on for ServiceNow.
- Upgrade the Common Information Model to version 4.14.0. For instructions, see Install the Splunk Common Information Model Add-on.

#### Step 4: Upgrade Splunk Enterprise using the Python 3 runtime

Upgrade your Splunk Enterprise instance to version 8.0.0 and perform the Python 3 migration. For more information, see Choose your Splunk Enterprise upgrade path for the Python 3 migration in the Splunk Enterprise Installation Manual.

In distributed environments, always run the same Python version on both indexers and search heads.

Step 5: Retrain Predictive Analytics models
If you're using Predictive Analytics, confirm that data ingested to train any predictive models is still stored in Splunk software. If data has exceeded retention timeframes, re-ingest the data to feed the models.

Retrain all predictive models saved into each of your services. Retraining a model automatically replaces the existing model. For instructions, see Retrain a predictive model in ITSI.

Scenario 2: Upgrade to Splunk Enterprise 8.0.0 with Python 2
If you upgrade to Splunk Enterprise version 8.0.0 but want to use the Python 2 runtime, you still need to upgrade ITSI to version 4.4.0. However, you must use a pre-5.0.0 version of the Machine Learning toolkit.

Step 1: Upgrade to ITSI version 4.4.0
For more information, see Upgrade IT Service Intelligence on a single instance or Upgrade IT Service Intelligence in a search head cluster environment depending on your deployment architecture.

Step 2: Upgrade Splunk Enterprise using the Python 2 runtime
Upgrade your Splunk Enterprise instance to version 8.0.0 using the Python 2 runtime. For more information, see Upgrade using the Python 2 runtime and make minimal changes to Python code in the Splunk Enterprise Installation Manual.

Step 3: (Optional) Upgrade required add-ons
The Splunk Add-on for ServiceNow and the Common Information Model (CIM) can remain on older versions, or you can upgrade them if needed.

Scenario 3: Upgrade to ITSI 4.4.0 without Splunk Enterprise 8.0.0
ITSI version 4.4.0 supports both the Python 2.7 and Python 3.7 runtimes. Therefore, you can upgrade to ITSI 4.4.0 while still remaining on Splunk Enterprise versions 7.2.x - 7.3.x. For ITSI compatibility with Splunk Enterprise, see Splunk Enterprise system requirements.

The Splunk Add-on for ServiceNow and the Common Information Model (CIM) can remain on older versions, or you can upgrade them if needed.

Do not upgrade the Machine Learning Toolkit to version 5.0.0. Version 5.0.0 is only compatible with Python 3.

## Update Splunk MLTK models for Python 3

Check this manual often for updated information about the Splunk platform Python 3 migration. The content is subject to change.

Models that use Python 2 syntax should be unaffected by upgrading to Splunk Enterprise version 8.0, as the Python 2 interpreter will be used by default. However, to use Python 3 syntax, you will need to update your models after Splunk Enterprise version 8.0 has been deployed. Also, custom built models and models created with the Experiment Management Framework must be updated to work properly with Python 3.

To update models for the Python 3 release, in Splunk MLTK you will need to:

Rerun searches that feed custom models. Running searches again replaces the model.
Rerun the experiment workflow for any models stored in the Experiment Management Framework. Running the workflow again also replaces the model.
Confirm that data ingested to train any custom models is still stored in Splunk Enterprise. If data has exceeded retention timeframes, re-ingest the data to feed the model, and rebuild model workflows if necessary.
Recreate models including the partial_fit parameter.
For information about updating models, see the Splunk Machine Learning Toolkit.

## Splunk support policy

Check this manual often for updated information about the Splunk platform Python 3 migration. The content is subject to change.

Splunk will continue to support Splunk Enterprise 7.x releases following the Splunk Software Support Policy.

Splunk will not backport Python 3 to Splunk Enterprise 7.x or earlier. Splunk Enterprise 7.x releases will use Python 2.7, while the Splunk Enterprise version 8.0 will support Python 2.7 and Python 3.7.

After the Python 2 end of life date on January 1st, 2020, Splunk will no longer receive security updates and fixes from the Python community to Python 2 code in Splunk Enterprise. This will not impair Splunk's ability to provide support for Splunk Enterprise, including Python 2.7. However, to continue to leverage community support and maintain compatibility with the many third party projects that use Python, Splunk will migrate Splunk Enterprise, supported Premium Solutions, and Splunk-built Splunkbase apps to Python 3.7 compatibility.

## Resources for Python 3 migration

Check this manual often for updated information about the Splunk platform Python 3 migration. The content is subject to change.

Splunk admin and developer tools
Splunk provides the Splunk Platform Upgrade Readiness App to scan an entire Splunk Enterprise instance for components impacted by the Python 3 migration. The Splunk Platform Upgrade Readiness app identifies removed features and list file paths to Python files so that you can update them. For more information, see the Splunk Platform Upgrade Readiness App.

Also, the AppInspect tools now checks for features that will be impacted by Python 3 migration, using either the AppInspect CLI or API. AppInspect will scan for features that require revision as prerequisites for upgrading to the Splunk Enterprise version 8.0. AppInspect will not scan for Python scripts in particular, but developers can use the Splunk Upgrade Readiness app, or identify Python scripts that require revision due to the Python 3 migration following the guidance covered in Python development with Splunk Enterprise. For more information, see the Splunk AppInspect tool.

Splunk Answers and Splunk user groups on Slack
For additional advice on preparing to migrate the Splunk platform to Python 3, join the discussions on Splunk Answers and on Slack. On Splunk Answers, follow the Python3 tag. On Slack, request to join the splunk-usergroups workspace, then join the #python3-migration channel.